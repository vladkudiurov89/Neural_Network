# -*- coding: utf-8 -*-
"""DZ-15(Light).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DkjEAP7kUKVUs5sprn8S73h7kqesk5xH
"""

# Commented out IPython magic to ensure Python compatibility.
# Загружаем библиотеки 
import random as random
import numpy as np 
import matplotlib.pyplot as plt 
import matplotlib.colors as colors 

# %matplotlib inline

# Функция получения выжившей популяции
def getSurvPopul(popul, val, nsurv, reverse):
    newpopul = [] 
    sval = sorted(val, reverse=reverse)   
    for i in range(nsurv):
        index = val.index(sval[i])
        newpopul.append(popul[index])
    return newpopul, sval

# Функция получения родителей
def getParents(curr_popul, nsurv):
    indexp1 = random.randint(0, nsurv - 1) 
    indexp2 = random.randint(0, nsurv - 1)   
    botp1 = curr_popul[indexp1] 
    botp2 = curr_popul[indexp2]   
    return botp1, botp2

# Функция смешивания (кроссинговера) двух родителей
def crossPointFrom2Parents(botp1, botp2, j):       
    pindex = random.random()
    if pindex < 0.5:
        x = botp1[j]
    else:
        x = botp2[j]
    return x

"""Размер Популяция = 100; Коэфициент Мутации = 0,15; Количество Выживших = 10"""

n = 100 # Размер популяции
nsurv = 10 # Количество выживших (столько лучших переходит в новую популяцию)
nnew = n - nsurv # Количество новых (столько новых ботов создается)
l = 12 # Длина бота
epohs = 500 # Количество эпох
mut = 0.15 # Коэфициент мутаций
# *******************
popul = [] # Двумерный массив популяции, размерностью [n, l]. 100 ботов по 12 компонентов каждый
val = [] # Одномерный массив значений этих ботов

for i in range(n):
    popul.append([])
    for j in range(l):
        popul[i].append(random.random()) 

# *******************
for it in range(epohs):
    val = []
    for i in range(n-1):
        bot = popul[i]
        x = bot[0] + 5*bot[1] + 10*bot[2] + 25*bot[3]
        y = bot[4] + 5*bot[5] + 10*bot[6] + 25*bot[7]
        z = bot[8] + 5*bot[9] + 10*bot[10] + 25*bot[11]
        # для кодирования применяем эту функцию f = x^2/y + z*(12-z) + 5*y/x
        f = x**2/2 + z*(12-z) + 5*y/x  
        val.append(abs(f))

    newpopul, sval = getSurvPopul(popul, val, nsurv, 0) # Получаем новую популяцию и сортированный список значнией
    print(it, " ", [round(s,4) for s in sval[0:5]]) # Выводим 5 лучших ботов
 
    for i in range(nnew): # Проходимся в цикле nnew-раз 
        botp1, botp2 = getParents(newpopul, nsurv) # Из newpopul(новой популяции) получаем двух случайных родителей-ботов
        newbot = [] # Массив для нового бота
        # проходимся по длине бота и осуществляем смешивание/скрещивание от родителей
        for j in range(l): # Проходим по всей длине бота
            x = crossPointFrom2Parents(botp1, botp2, j) # Получаем значение для j-ого компонента бота
            x += mut*(2*random.random() - 1.0) #Добавялем к значению бота случайную величину, зависящую от коэфециента мутации        
            newbot.append(x) # Добавялем новое значение в бота      
        newpopul.append(newbot) # Добавляем бота в новую популяцию 
        #(таким образом к nsurv-лучших ботов предыдующей популяции добавится nnew-новых ботов)
    
    popul = newpopul # Записываем в popul посчитанную новую популяцию

bot = popul[0] # Берем первого (лучшего) бота в финальной популяции
x = bot[0] + 5*bot[1] + 10*bot[2] + 25*bot[3]
y = bot[4] + 5*bot[5] + 10*bot[6] + 25*bot[7] 
z = bot[8] + 5*bot[9] + 10*bot[10] + 25*bot[11]
f = x**2/2 + z*(12-z) + 5*y/x   # Считаем значение функции
print(f"Бот: {bot}")  
print(f'x ={round(x, 4)} y ={round(y, 4)} z ={round(z, 4)}')
print(f"f ={round(f, 6)}") # Выводим значение функции (которое должно быть максимально близко к 0 по условию задачи)

data = [[n, mut, nsurv, f]]

"""Размер Популяция = 200; Коэфициент Мутации = 0,25; Количество Выживших = 20"""

n = 200 # Размер популяции
nsurv = 20 # Количество выживших (столько лучших переходит в новую популяцию)
nnew = n - nsurv # Количество новых (столько новых ботов создается)
l = 12 # Длина бота
epohs = 500 # Количество эпох
mut = 0.25 # Коэфициент мутаций
# *******************
popul = [] # Двумерный массив популяции, размерностью [n, l]. 100 ботов по 12 компонентов каждый
val = [] # Одномерный массив значений этих ботов

for i in range(n):
    popul.append([])
    for j in range(l):
        popul[i].append(random.random()) 

# *******************
for it in range(epohs):
    val = []
    for i in range(n-1):
        bot = popul[i]
        x = bot[0] + 5*bot[1] + 10*bot[2] + 25*bot[3]
        y = bot[4] + 5*bot[5] + 10*bot[6] + 25*bot[7]
        z = bot[8] + 5*bot[9] + 10*bot[10] + 25*bot[11]
        # для кодирования применяем эту функцию f = x^2/y + z*(12-z) + 5*y/x
        f = x**2/2 + z*(12-z) + 5*y/x  
        val.append(abs(f))

    newpopul, sval = getSurvPopul(popul, val, nsurv, 0) # Получаем новую популяцию и сортированный список значнией
    print(it, " ", [round(s,4) for s in sval[0:5]]) # Выводим 5 лучших ботов
 
    for i in range(nnew): # Проходимся в цикле nnew-раз 
        botp1, botp2 = getParents(newpopul, nsurv) # Из newpopul(новой популяции) получаем двух случайных родителей-ботов
        newbot = [] # Массив для нового бота
        # проходимся по длине бота и осуществляем смешивание/скрещивание от родителей
        for j in range(l): # Проходим по всей длине бота
            x = crossPointFrom2Parents(botp1, botp2, j) # Получаем значение для j-ого компонента бота
            x += mut*(2*random.random() - 1.0) #Добавялем к значению бота случайную величину, зависящую от коэфециента мутации        
            newbot.append(x) # Добавялем новое значение в бота      
        newpopul.append(newbot) # Добавляем бота в новую популяцию 
        #(таким образом к nsurv-лучших ботов предыдующей популяции добавится nnew-новых ботов)
    
    popul = newpopul # Записываем в popul посчитанную новую популяцию

bot = popul[0] # Берем первого (лучшего) бота в финальной популяции
x = bot[0] + 5*bot[1] + 10*bot[2] + 25*bot[3]
y = bot[4] + 5*bot[5] + 10*bot[6] + 25*bot[7] 
z = bot[8] + 5*bot[9] + 10*bot[10] + 25*bot[11]
f = x**2/2 + z*(12-z) + 5*y/x   # Считаем значение функции
print(f"Бот: {bot}")  
print(f'x ={round(x, 4)} y ={round(y, 4)} z ={round(z, 4)}')
print(f"f ={round(f, 6)}") # Выводим значение функции (которое должно быть максимально близко к 0 по условию задачи)

data = data + [[n, mut, nsurv, f]]

"""Размер Популяция = 150; Коэфициент Мутации = 0,30; Количество Выживших = 20"""

n = 150 # Размер популяции
nsurv = 10 # Количество выживших (столько лучших переходит в новую популяцию)
nnew = n - nsurv # Количество новых (столько новых ботов создается)
l = 12 # Длина бота
epohs = 500 # Количество эпох
mut = 0.25 # Коэфициент мутаций
# *******************
popul = [] # Двумерный массив популяции, размерностью [n, l]. 100 ботов по 12 компонентов каждый
val = [] # Одномерный массив значений этих ботов

for i in range(n):
    popul.append([])
    for j in range(l):
        popul[i].append(random.random()) 

# *******************
for it in range(epohs):
    val = []
    for i in range(n-1):
        bot = popul[i]
        x = bot[0] + 5*bot[1] + 10*bot[2] + 25*bot[3]
        y = bot[4] + 5*bot[5] + 10*bot[6] + 25*bot[7]
        z = bot[8] + 5*bot[9] + 10*bot[10] + 25*bot[11]
        # для кодирования применяем эту функцию f = x^2/y + z*(12-z) + 5*y/x
        f = x**2/2 + z*(12-z) + 5*y/x  
        val.append(abs(f))

    newpopul, sval = getSurvPopul(popul, val, nsurv, 0) # Получаем новую популяцию и сортированный список значнией
    print(it, " ", [round(s,4) for s in sval[0:5]]) # Выводим 5 лучших ботов
 
    for i in range(nnew): # Проходимся в цикле nnew-раз 
        botp1, botp2 = getParents(newpopul, nsurv) # Из newpopul(новой популяции) получаем двух случайных родителей-ботов
        newbot = [] # Массив для нового бота
        # проходимся по длине бота и осуществляем смешивание/скрещивание от родителей
        for j in range(l): # Проходим по всей длине бота
            x = crossPointFrom2Parents(botp1, botp2, j) # Получаем значение для j-ого компонента бота
            x += mut*(2*random.random() - 1.0) #Добавялем к значению бота случайную величину, зависящую от коэфециента мутации        
            newbot.append(x) # Добавялем новое значение в бота      
        newpopul.append(newbot) # Добавляем бота в новую популяцию 
        #(таким образом к nsurv-лучших ботов предыдующей популяции добавится nnew-новых ботов)
    

bot = popul[0] # Берем первого (лучшего) бота в финальной популяции
x = bot[0] + 5*bot[1] + 10*bot[2] + 25*bot[3]
y = bot[4] + 5*bot[5] + 10*bot[6] + 25*bot[7] 
z = bot[8] + 5*bot[9] + 10*bot[10] + 25*bot[11]
f = x**2/2 + z*(12-z) + 5*y/x   # Считаем значение функции
print(f"Бот: {bot}")  
print(f'x ={round(x, 4)} y ={round(y, 4)} z ={round(z, 4)}')
print(f"f ={round(f, 6)}") # Выводим значение функции (которое должно быть максимально близко к 0 по условию задачи)
data = data + [[n, mut, nsurv, f]]

import pandas as pd
df = pd.DataFrame(data, columns = ['Размер популяции', 'Коэфицент Мутации', 'Количество выживших','Значение функции'])
df.index = df.index + 1
df

"""Поезда: 1, 12, 72, 4, 55, 1

Грузы: 1, 1, 1, 1, 4, 3, 3, 3, 1, 27, 31, 7, 7, 11, 22, 7, 7, 8

"""

# Вместимость каждого поезда
train = np.array([1, 12, 72, 4, 55, 1])
# Количество каждого груза (сумма грузов должна быть равна вместимости всех поездов (85=85))
size = np.array([1, 1, 1, 1, 4, 3, 3, 3, 1, 27, 31, 7, 7, 11, 22, 7, 7, 8]) 

print(train.sum())
print(size.sum())
print(train.shape)
print(size.shape)

n = 100 # Общее число ботов
nsurv = 20 # Количество выживших (столько лучших переходит в новую популяцию)
nnew = n-nsurv # Количество новых (столько новых ботов создается)
epohs = 2500 # количество эпох
mut = 0.4 # коэфициент мутаций

# Длина бота(количество единиц груза) (Каждый компонент указывает индекс поезда, в котором этот груз будет размещен)
l = size.shape[0] 
trains = train.shape[0] 

popul = [] 
val = [] 

plotmeanval = [] 
plotminval = [] 
# Проходим по всей длине популяции
for i in range(n): 
    popul.append([]) 
    for j in range(l):
        # В каждый компонент бота записываем рандомное значение в диапазоне от 0 до количества поездов
        popul[i].append(random.randint(0, trains - 1)) 

for it in range(epohs):
    if (it == 500): # Меняем коэфициент мутации после 500-ой эпохи
        mut = 0.1   
    if (it == 1000): # Меняем коэфициет мутации после 1000-ой эпохи
        mut = 0.05  

    val = [] 
    for i in range(n): 
        bot = popul[i]
        trainfill = np.array([0, 0, 0, 0, 0, 0, 0, 0])
        for j in range(l):
            trainfill[bot[j]] += size[j]
        f = 0 # Обнуляем ошибку i-го бота 
        for t in range(trains):
            f += abs(train[t] - trainfill[t]) 
        val.append(f)
    # Добавляем в val значение ошибки для i-го бота    
    newpopul, sval = getSurvPopul(popul, val, nsurv, 0)
    print(it, " ", sum(val) / len(val), " ", sval[0:20])   
    plotmeanval.append(sum(val) / len(val)) 
    plotminval.append(sval[0])
    # Проходимся в цикле nnew-раз
    for i in range(nnew): 
        botp1, botp2 = getParents(newpopul, nsurv)
        newbot = []
        for j in range(l):
            x = crossPointFrom2Parents(botp1, botp2, j)
            # С вероятностью mut сбрасываем значение j-ого компонента бота на случайное
            if (random.random() < mut):
                x = random.randint(0, trains - 1)        
            newbot.append(x)     
        newpopul.append(newbot)   
    popul = newpopul

# построение графиков 
plt.plot(plotmeanval, label='Среднее по популяции')
plt.plot(plotminval, label='Лучший бот')
plt.xlabel('Эпоха обучения')
plt.ylabel('Значение функции')
plt.legend()
plt.show()

# Выводим 20 лучших ботов
for i in range(20):
    print(popul[i])

bot = popul[0] # Берем лучшее значение в популяции
print ('Значения лучшего бота:', bot) # Выводим значения бота (каждый параметр хранит номер поезда, в который следует разместить груз)

trainfill = np.zeros(trains, dtype = 'int32') # Массив заполненности поездов
for j in range(l): # Проходим по всей длине бота
    trainfill[bot[j]] += size[j] # Увеличиваем заполненность bot[j]-ого поезда на size[j]

print ('Вместимость поездов по боту:', trainfill) # Выводим заполненность поездов в соответствии с ботом
print ('Реальная вместимость поездов:', train) # Выводим реальную вместимость поездов

"""Поезда: 10, 10, 10, 12, 12

Грузы: 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 6, 6

Расстановка грузов по поездам с дополнительным условием - надо заполнить поезда максимально равномерно, но можно не полностью,

"""

# Вместимость каждого поезда
train = np.array([10, 10, 10, 12, 12, 12])
# Количество каждого груза (сумма грузов должна быть равна вместимости всех поездов (85=85))
size = np.array([1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 6, 6]) 

print(train.sum())
print(size.sum())
print(train.shape)
print(size.shape)

n = 300 # Общее число ботов
nsurv = 30 # Количество выживших (столько лучших переходит в новую популяцию)
nnew = n-nsurv # Количество новых (столько новых ботов создается)
epohs = 3000 # количество эпох
mut = 0.8 # коэфициент мутаций

# Длина бота(количество единиц груза) (Каждый компонент указывает индекс поезда, в котором этот груз будет размещен)
l = size.shape[0] 
trains = train.shape[0] 

popul = [] 
val = [] 

plotmeanval = [] 
plotminval = [] 
# Проходим по всей длине популяции
for i in range(n): 
    popul.append([]) 
    for j in range(l):
        # В каждый компонент бота записываем рандомное значение в диапазоне от 0 до количества поездов
        popul[i].append(random.randint(0, trains - 1)) 

for it in range(epohs):
    if (it == 500): # Меняем коэфициент мутации после 500-ой эпохи
        mut = 0.7   
    if (it == 1000): # Меняем коэфициет мутации после 1000-ой эпохи
        mut = 0.5  
    if (it == 1500): # Меняем коэфициет мутации после 1500-ой эпохи
        mut = 0.3 

    val = [] 
    for i in range(n): 
        bot = popul[i]
        trainfill = np.array([0, 0, 0, 0, 0, 0])
        for j in range(l):
            trainfill[bot[j]] += size[j]
        f = 0 # Обнуляем ошибку i-го бота 
        for t in range(trains):
            f += abs(train[t] - trainfill[t]) 
        val.append(f)
    # Добавляем в val значение ошибки для i-го бота    
    newpopul, sval = getSurvPopul(popul, val, nsurv, 0)
    print(it, " ", sum(val) / len(val), " ", sval[0:20])   
    plotmeanval.append(sum(val) / len(val)) 
    plotminval.append(sval[0])
    # Проходимся в цикле nnew-раз
    for i in range(nnew): 
        botp1, botp2 = getParents(newpopul, nsurv)
        newbot = []
        for j in range(l):
            x = crossPointFrom2Parents(botp1, botp2, j)
            # С вероятностью mut сбрасываем значение j-ого компонента бота на случайное
            if (random.random() < mut):
                x = random.randint(0, trains - 1)        
            newbot.append(x)     
        newpopul.append(newbot)   
    popul = newpopul

# построение графиков 
plt.plot(plotmeanval, label='Среднее по популяции')
plt.plot(plotminval, label='Лучший бот')
plt.xlabel('Эпоха обучения')
plt.ylabel('Значение функции')
plt.legend()
plt.show()

# Выводим 20 лучших ботов
for i in range(20):
    print(popul[i])

bot = popul[0] # Берем лучшее значение в популяции
print ('Значения лучшего бота:', bot) # Выводим значения бота (каждый параметр хранит номер поезда, в который следует разместить груз)

trainfill = np.zeros(trains, dtype = 'int32') # Массив заполненности поездов
for j in range(l): # Проходим по всей длине бота
    trainfill[bot[j]] += size[j] # Увеличиваем заполненность bot[j]-ого поезда на size[j]

print ('Вместимость поездов по боту:', trainfill) # Выводим заполненность поездов в соответствии с ботом
print ('Реальная вместимость поездов:', train) # Выводим реальную вместимость поездов

size



