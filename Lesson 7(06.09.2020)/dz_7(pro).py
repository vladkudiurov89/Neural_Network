# -*- coding: utf-8 -*-
"""DZ-7(PRO).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h5iwOilyc2yvn4ZKra0tAvaKr98Y-wmr
"""

# Commented out IPython magic to ensure Python compatibility.
#Загружаем библиотеки

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from tensorflow.keras.layers import concatenate, Input, Dense, Dropout, BatchNormalization, Flatten, Conv1D, LSTM 
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from tensorflow.keras import utils
from tensorflow.keras.models import Sequential, Model 
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.sequence import TimeseriesGenerator

# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

base_data = pd.read_csv('/content/drive/My Drive/datasets/date_csv/traff.csv')
base_data.head()

# Убираем ненужную колонку с датой
base_data = base_data.iloc[:,1:]
base_data.columns = ['traff']
base_data.head()

# Удаляем ненужный символ ','
a = []
for i in range(len(base_data)):
    
    a.append(float(base_data['traff'][i].replace(',','')))

index = list(range(len(base_data)))
data = pd.DataFrame(a, columns = ['traff'], index = index)
data

xLen = 60
valLen = 300 

trainLen = data.shape[0]-valLen 

xTrain,xTest = data[:trainLen], data[trainLen+xLen+2:]

xScaler = MinMaxScaler()
xScaler.fit(xTrain)
xTrain = xScaler.transform(xTrain)
xTest = xScaler.transform(xTest)

yTrain,yTest = np.reshape(data[:trainLen],(-1,1)), np.reshape(data[trainLen+xLen+2:],(-1,1)) 
yScaler = MinMaxScaler()
yScaler.fit(yTrain)
yTrain = yScaler.transform(yTrain)
yTest = yScaler.transform(yTest)

trainDataGen = TimeseriesGenerator(xTrain, yTrain, 
                               length=xLen, sampling_rate=1, 
                               batch_size=20)                

testDataGen = TimeseriesGenerator(xTest, yTest,
                               length=xLen, sampling_rate=1,
                               batch_size=20)

print(xTrain.shape)
print(xTest.shape)
print(yTrain.shape)
print(yTest.shape)
print(trainDataGen[0][0].shape)
# print(testDataGen.shape)

def getPred(currModel, xVal, yVal, yScaler):

  predVal = yScaler.inverse_transform(currModel.predict(xVal))
  yValUnscaled = yScaler.inverse_transform(yVal)
  
  return (predVal, yValUnscaled)

def showPredict(start, step, channel, predVal, yValUnscaled):
  plt.plot(predVal[start:start+step, 0],
           label='Прогноз')
  plt.plot(yValUnscaled[start:start+step, channel], 
           label='Базовый ряд')
  plt.xlabel('Время')
  plt.ylabel('Значение Close')
  plt.legend()
  plt.show()
  
def correlate(a, b):

  ma = a.mean() 
  mb = b.mean()
  mab = (a*b).mean() 
  sa = a.std() 
  sb = b.std() 
  
  val = 1
  if ((sa>0) & (sb>0)):
    val = (mab-ma*mb)/(sa*sb)
  return val

def showCorr(channels, corrSteps, predVal, yValUnscaled):
  for ch in channels:
    corr = []
    yLen = yValUnscaled.shape[0] 
    for i in range(corrSteps):
      corr.append(correlate(yValUnscaled[:yLen-i,ch], predVal[i:, 0]))

    own_corr = [] 

    for i in range(corrSteps):
      own_corr.append(correlate(yValUnscaled[:yLen-i,ch], yValUnscaled[i:, ch]))

    plt.plot(corr, label='Предсказание на ' + str(ch+1) + ' шаг')
    plt.plot(own_corr, label='Эталон')
    plt.xlabel('Время')
    plt.ylabel('Значение')
    plt.legend()
    plt.show()





DataGen = TimeseriesGenerator(xTest, yTest,
                               length=xLen, sampling_rate=1,
                               batch_size=len(xTest))
xVal = []
yVal = []
for i in DataGen:
  xVal.append(i[0])
  yVal.append(i[1])

xVal = np.array(xVal)
yVal = np.array(yVal)

modelC = Sequential()

modelC.add(Conv1D(2048, 5, input_shape = (xLen,1), activation='linear'))
modelC.add(Flatten())
modelC.add(Dense(2048, activation='linear'))
modelC.add(Dense(1, activation='linear'))

modelC.compile(loss='mse', optimizer=Adam(lr=1e-4))

history = modelC.fit_generator(
                    trainDataGen,
                    epochs=10, verbose=1,
                    validation_data=testDataGen)

plt.plot(history.history['loss'], 
         label='Средняя абсолютная ошибка на обучающем наборе')
plt.plot(history.history['val_loss'], 
         label='Средняя абсолютная ошибка на проверочном наборе')
plt.ylabel('Средняя ошибка')
plt.legend()
plt.show()

#Прогнозируем данные текущей сетью
currModel = modelC
(predVal, yValUnscaled) = getPred(currModel, xVal[0], yVal[0], yScaler)


showPredict(0, 4000, 0, predVal, yValUnscaled)

showCorr([0], 60, predVal, yValUnscaled)